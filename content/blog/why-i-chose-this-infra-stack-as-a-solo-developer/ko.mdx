---
title: "1인 개발자로서 이 인프라 스택을 선택한 이유"
description: "GCP Cloud Run, Neon, Cloudflare, Pulumi — 여러 프로젝트를 운영하는 1인 개발자를 위한 실용적인 인프라 스택."
date: "2026-02-08"
tags:
  - infrastructure
  - devops
  - solo-developer
  - pulumi
  - cloudflare
  - gcp
  - neon
draft: false
---

1인 개발자로서 여러 프로젝트를 동시에 운영하고 있다. 각 프로젝트는 운영 비용이 저렴하고, 배포가 쉬워야 하며 — 아무도 잘 얘기하지 않는 부분인데 — 프로젝트를 종료할 때 **정리하기도 쉬워야** 한다.

여러 조합을 시도한 끝에, 사진 기반 식사 기록 앱인 [Mealio](https://github.com/zzoohub/mealio) 같은 프로젝트에서 쓰고 있는 스택에 정착했다. 각 구성 요소를 선택한 이유를 공유한다.

## GCP Cloud Run — 유휴 상태에서 비용이 0인 서버

Cloud Run은 완전 관리형 컨테이너 플랫폼으로, **제로 스케일링**을 지원한다. 이 부분이 1인 개발자에게는 결정적이다.

내 프로젝트 대부분은 트래픽이 불규칙하다. 하루에 수백 건의 요청이 올 때도 있고, 아예 없는 날도 있다. Cloud Run은 유휴 상태에서 비용이 발생하지 않는다. 요청이 들어오는 순간 컨테이너가 몇 초 만에 기동된다.

Mealio의 Rust/Axum API에 적용한 Cloud Run 설정은 다음과 같다:

- **0~3개 인스턴스** 오토스케일링 (제로 스케일링)
- 인스턴스당 **CPU 1코어, 메모리 512Mi**
- 인스턴스당 **최대 동시 요청 80건**
- 기동 및 활성 상태 헬스체크

90%의 시간 동안 아무것도 안 하는 월 $5 VPS와 비교하면, Cloud Run은 실제 오토스케일링, TLS, 헬스체크를 갖춘 프로덕션 서비스를 실제 사용량에 대해서만 비용을 지불하고 배포할 수 있다. 트래픽이 적은 사이드 프로젝트라면 월 한 자릿수 달러로 운영 가능하다.

컨테이너 기반 모델이기 때문에 특정 런타임에 종속되지 않는다는 것도 장점이다. 지금은 Rust 바이너리를 배포하고 있지만, Go나 Node.js로 바꾸더라도 배포 방식은 동일하다: Docker 이미지 빌드, 푸시, 끝.

## Neon — 오버헤드 없는 매니지드 PostgreSQL

데이터베이스로는 [Neon](https://neon.tech)을 선택했다. 서버리스 PostgreSQL로, 사용량에 따라 데이터베이스가 스케일링되고 브랜칭 기능도 무료로 제공된다.

### Supabase는?

Supabase도 좋은 제품이다. 특히 사용자가 아시아에 집중되어 있다면 진지하게 고려할 만하다. **Neon은 아직 서울 리전을 지원하지 않는다.** 한국 사용자를 대상으로 한 서비스라면 이 부분이 중요하다. Supabase는 서울 리전을 지원하며, 인증·스토리지·실시간 기능을 함께 제공해서 별도 서비스가 필요 없다.

하지만 내 상황에서는 Neon이 더 낫다:

1. **순수 PostgreSQL** — 추가 추상화 계층이 없다. Rust에서 SQLx로 컴파일 타임 체크 쿼리를 쓰는데, 데이터베이스는 그냥 PostgreSQL이면 된다.
2. **브랜칭** — 프로덕션에 마이그레이션을 적용하기 전에 데이터베이스 브랜치를 만들어 테스트할 수 있다. 전용 스테이징 환경이 없을 때 매우 유용하다.
3. **제로 스케일링 컴퓨트** — Cloud Run과 마찬가지로 Neon도 유휴 컴퓨트를 중지한다. 개발 브랜치는 비용이 거의 들지 않는다.
4. **넉넉한 무료 티어** — 사이드 프로젝트나 초기 단계 제품에 충분하다.

Pulumi에서 Neon 프로젝트를 만드는 건 몇 줄이면 된다:

```typescript
const neonProject = new neon.Project("mealio", {
  name: "mealio",
  regionId: "aws-us-east-1",
  pgVersion: 18,
  historyRetentionSeconds: 21600,
});
```

## Cloudflare — 더 저렴한 엣지 네트워크

Cloudflare를 적극 활용하고 있다: 프론트엔드 호스팅에 Workers, 오브젝트 스토리지에 R2, 그리고 글로벌 배포에 엣지 네트워크를 쓴다.

### Vercel은?

Vercel은 Next.js 배포의 기본 선택지이고, 완성도 높은 제품이다. 하지만 1인 개발자가 여러 프로젝트를 운영하면 비용이 빠르게 쌓인다.

Cloudflare의 가격 정책이 훨씬 관대하다:

- **Workers**: 무료 티어에서 하루 100,000 요청. Vercel 무료 티어는 월 100GB 대역폭에 함수 제한이 더 엄격하다.
- **R2**: 이그레스 비용 제로. 이미지나 파일을 서빙하는 앱에는 엄청난 장점이다. S3 이그레스 비용은 스케일에서 예상치 못한 청구서를 만들 수 있다.
- **글로벌 배포**: Cloudflare는 전 세계 300개 이상의 데이터센터에서 운영된다. 모든 배포가 즉시 전 세계에서 접근 가능하다.

Mealio에서는 사용자가 업로드한 식사 사진을 R2에 저장한다. 이그레스 비용이 없으니 바이럴이 되더라도 깜짝 청구서 걱정이 없다.

트레이드오프가 있다면? Next.js에 대한 Cloudflare의 개발자 경험은 Vercel만큼 매끄럽지는 않다. `@cloudflare/next-on-pages`가 필요하고, 간혹 호환성 이슈를 만날 수 있다. 하지만 비용 절감과 글로벌 성능을 생각하면 자비로 운영하는 입장에서 충분히 가치가 있다.

## Pulumi — 셋업만큼 중요한 정리

이 스택에서 내가 가장 강하게 추천하는 부분이자, 대부분의 1인 개발자가 간과하는 부분이다.

**1인 개발자는 출시하는 프로젝트보다 종료하는 프로젝트가 더 많다.** 이건 자연스럽고 건강한 일이다. 실험하고, 아이디어를 검증하고, 다음으로 넘어간다. 하지만 버려진 프로젝트마다 인프라의 흔적이 남는다: 데이터베이스, 클라우드 스토리지 버킷, IAM 역할, 컨테이너 레지스트리, DNS 레코드, 시크릿...

이걸 수동으로 하나하나 삭제하는 건 지루하고, 실수하기 쉽고, 의욕을 꺾는 작업이다. 필연적으로 뭔가를 빠뜨리고, 아무도 쓰지 않는 데이터베이스에 계속 비용을 내게 된다.

Pulumi는 이걸 명령어 하나로 해결한다:

```bash
pulumi destroy
```

모든 것이 사라진다. Cloud Run 서비스, Neon 데이터베이스, R2 버킷, IAM 바인딩, 시크릿 — 전부, 올바른 의존성 순서로 깔끔하게 제거된다.

### Terraform 대신 Pulumi를 선택한 이유

둘 다 훌륭한 IaC 도구지만, Pulumi는 TypeScript로 인프라를 작성할 수 있다 — 이미 매일 쓰는 언어로. HCL을 배울 필요도 없고, 컨텍스트 스위칭도 없다. 타입 안전성, IDE 자동완성, 루프·조건문·추상화를 자연스럽게 사용할 수 있다.

Mealio 인프라 진입점을 간략화하면 이렇다:

```typescript
import { cloudRunService } from "./src/gcp-cloudrun";
import { neonProject } from "./src/neon";
import { r2Bucket } from "./src/cloudflare";
import { secrets } from "./src/gcp-secrets";
import { registry } from "./src/gcp-registry";
import { wif } from "./src/gcp-iam";
```

각 모듈이 집중된 TypeScript 파일이다. 새 프로젝트를 시작할 때 구조를 복사하고, 이름과 설정만 바꾸고, `pulumi up`. 프로젝트가 끝나면 `pulumi destroy`. 남은 리소스도 없고, 잊힌 청구서도 없다.

### protect 플래그

실수로 destroy되면 안 되는 프로덕션 리소스를 위해 Pulumi에는 `protect` 옵션이 있다:

```typescript
const db = new neon.Project("my-db", { ... }, { protect: true });
```

중요한 리소스가 실수로 삭제되지 않는다는 확신을 가지면서도, 나머지는 깔끔하게 정리할 수 있다.

## 전체 구성

일반적인 프로젝트에서 이 구성 요소들이 어떻게 맞물리는지 정리하면:

| 계층 | 서비스 | 선택 이유 |
|------|--------|-----------|
| **서버** | GCP Cloud Run | 제로 스케일링, 컨테이너 기반, 사용량 과금 |
| **데이터베이스** | Neon | 서버리스 PostgreSQL, 브랜칭, 제로 스케일링 |
| **프론트엔드 / CDN** | Cloudflare Workers | 글로벌 엣지, 이그레스 무료, 넉넉한 무료 티어 |
| **스토리지** | Cloudflare R2 | S3 호환, 이그레스 비용 제로 |
| **시크릿** | GCP Secret Manager | Cloud Run 네이티브 통합 |
| **CI/CD** | GitHub Actions | 퍼블릭 레포 무료, GCP WIF 인증 |
| **IaC** | Pulumi | TypeScript, 쉬운 정리, 리소스 보호 |

## 이 스택이 최적화하는 것

이 스택은 10명 규모의 팀과 벤처 투자금이 있는 스타트업을 위한 게 아니다. 이건 다음과 같은 1인 개발자를 위한 스택이다:

- **여러 프로젝트를 운영**하면서 각각의 유휴 비용이 저렴해야 하는 사람
- 쿠버네티스나 VM 관리 없이 **빠르게 배포**하고 싶은 사람
- 셋업뿐 아니라 **종료까지 포함한 전체 라이프사이클**을 생각하는 사람
- **자비로 운영**하면서 예측 가능한 종량제 비용을 원하는 사람
- 하나의 벤더에 모든 걸 맡기기보다 **단순함**을 중시하는 사람

이 선택들을 관통하는 공통 키워드는 **제로 스케일링 경제성과 운영 단순성**이다. 프로젝트가 활성 상태일 때 인프라가 스케일업된다. 그렇지 않을 때는 비용이 거의 없다. 그리고 프로젝트를 종료할 때, 명령어 하나로 모든 것을 정리한다.

이것이 1인 개발자에게 실제로 필요한 인프라의 자유다.
