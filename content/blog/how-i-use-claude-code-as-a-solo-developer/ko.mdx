---
title: "솔로 개발자로서 Claude Code를 사용하는 방법"
description: "21개 커스텀 스킬, 7개 전문 에이전트, 그리고 AI 페어 프로그래밍을 반복 가능한 워크플로우로 만드는 CLAUDE.md 시스템. 내가 프로젝트를 배포하는 비밀 뒤에 있는 셋업."
date: "2026-02-17"
tags:
  - claude-code
  - ai
  - solo-developer
  - workflow
draft: false
---

혼자서 프로덕트를 배포한다. 개인 웹사이트, 식사 기록 앱, AI 콘텐츠 플랫폼 — 전부 한 사람이 관리한다. 비결은 더 열심히 일하는 게 아니다. Claude Code가 팀처럼 동작하게 만드는 시스템이다.

지난 몇 달간, Claude Code가 단순히 코드를 자동완성하는 수준을 넘어서 프로젝트 컨벤션을 따르고, 보안 리뷰를 수행하고, 100% 커버리지로 테스트를 작성하고, 시니어 DBA처럼 데이터베이스 스키마를 리뷰하는 셋업을 만들었다. 모든 프로젝트에 동일한 품질 기준이 자동으로 적용된다.

어떻게 동작하는지 설명한다.

## CLAUDE.md 시스템

모든 프로젝트 루트에 `CLAUDE.md` 파일이 있다. 그 코드베이스에서 AI 행동의 헌법이라고 생각하면 된다. 기술 스택, 아키텍처 패턴, 핵심 제약사항, 그리고 가장 중요하게 — **어떤 스킬과 에이전트를 사용해야 하는지**를 정의한다.

모든 프로젝트에 걸친 핵심 패턴:

```
1. 모든 구현은 반드시 지정된 스킬을 사용
2. 구현 후, 두 에이전트를 병렬로 실행:
   - security-reviewer → 감사 → 수정
   - tester → 변경된 코드만 테스트 → 수정
```

이건 제안이 아니다. 하드 룰이다. 모든 기능, 모든 버그 수정, 모든 리팩토링이 이 파이프라인을 거친다. `CLAUDE.md` 파일이 이걸 자동화한다 — Claude Code가 매 세션 시작 시 읽고 요청하지 않아도 워크플로우를 따른다.

Next.js 웹사이트의 CLAUDE.md는 `vercel-react-best-practices`와 `vercel-composition-patterns` 스킬을 강제한다. Rust API는 `axum`과 `postgresql`. React Native 앱은 `react-native`과 `vercel-react-native-skills`. 코드 한 줄 쓰기 전에 올바른 전문 지식이 로드된다.

## 21개 스킬: 인코딩된 전문 지식

스킬은 Claude Code가 필요에 따라 로드하는 지식 파일이다. 직접 만든 것도 있고, 공식으로 제공되는 것도 있다. 7개 도메인에 걸쳐 21개를 사용한다:

**아키텍처 & 설계** — `data-modeling`, `api-design`, `ux-design`, `design-system`. 시스템 설계에 대한 내 사고방식을 인코딩한다: 엔티티 추출, REST 컨벤션, 인지 공학, 디자인 토큰.

**웹 프레임워크** — `vercel-react-best-practices` (8개 카테고리에 걸친 45개 규칙), `vercel-composition-patterns`, `nextjs`. `vercel-*` 이 붙은 스킬들은 **Vercel에서 공식 제공하는 스킬**이다 — 내가 만든 게 아니다. React 베스트 프랙티스 스킬 하나만으로도 워터폴 방지, 번들 최적화, 서버사이드 패턴, 리렌더 방지, 렌더링 전략을 커버한다. 프레임워크를 만든 사람들이 직접 "이렇게 써라"를 인코딩해서 제공하는 것이다. `nextjs`는 공식 스킬이 커버하지 않는 부분을 채우기 위해 직접 만든 커스텀 스킬이다.

**모바일** — `react-native`, `vercel-react-native-skills` (역시 Vercel 공식). React Native 전용 리스트 성능, 애니메이션, 상태 관리 패턴.

**백엔드** — `axum`, `axum-hexagonal`, `fastapi`, `fastapi-hexagonal`. Rust와 Python 스택 모두에 헥사고날 아키텍처 패턴이 내장되어 있다.

**데이터베이스** — `postgresql`, `sqlite`, `neon-postgres`. 페이지네이션, 전문 검색, N+1 쿼리, 무중단 마이그레이션, 파티셔닝 등의 문제 해결 패턴.

**AI/ML** — `langgraph`. ReAct 에이전트, 멀티 에이전트 시스템, 휴먼 인 더 루프 패턴.

**품질** — `security-checklists`, `web-vitals-checklist`, `i18n-patterns`, `web-design-guidelines`.

핵심 인사이트: 스킬은 문서가 아니다. **제약 조건**이다. Claude Code가 `vercel-react-best-practices`를 로드하면 React 패턴을 아는 것뿐 아니라 45개 규칙을 **따르도록 강제**된다. 워터폴 방지는 CRITICAL 우선순위. 번들 크기 최적화도 CRITICAL. 가이드라인이 아니라 가드레일이다.

이게 앞으로 큰 트렌드가 될 거라고 본다. 더 많은 프레임워크와 도구 벤더들이 공식 스킬을 배포할수록, AI 생성 코드의 기본 품질이 전반적으로 올라갈 것이다. 모든 주요 라이브러리가 베스트 프랙티스를 인코딩한 스킬을 제공하는 세상을 상상해보자 — 읽을 수도 있는 문서가 아니라, AI가 반드시 따라야 하는 제약 조건으로. 내가 직접 만든 커스텀 스킬들이 지금은 빈틈을 채우지만, 공식 스킬은 이미 해당 도메인에서 더 낫다.

## 7개 에이전트: 가상 팀

에이전트는 특정 작업을 자율적으로 처리하는 특화된 서브 프로세스다. 개발용과 기획용으로 나눠 7개를 운영한다:

### 개발 에이전트

**security-reviewer** — 모든 구현 후 보안 감사를 수행한다. OWASP 탑 10을 스캔하고, 시크릿 노출, SQL 인젝션, 커맨드 인젝션, XSS, IDOR, 레이스 컨디션을 체크한다. 심각도별로 분류하고, 결제 로직, 인증 변경, 암호화, 컴플라이언스 관련 코드는 나에게 에스컬레이션한다.

**tester** — 라인, 브랜치, 함수, 구문 커버리지 전부 100%를 목표로 한다. 변경된 코드를 분석하고, 테스트 전략을 계획하고, 테스트를 작성하고, 실행하고, 커버리지가 완료될 때까지 반복한다. 중요한 규칙: 애플리케이션 코드는 절대 수정하지 않고 테스트 파일만 작성한다.

**database-reviewer** — 시니어 DBA 관점으로 접근한다. "이 스키마가 현실에서 살아남을 수 있는가?" 외래 키 제약 조건 누락, 혼합된 ID 전략, 문서화되지 않은 비정규화, 전부 nullable 안티패턴을 검사한다. 멀티 테이블 마이그레이션과 PK 전략 변경은 에스컬레이션한다.

**ui-engineer** — 비즈니스 로직 제로인 순수 UI 컴포넌트를 만든다. 웹에서는 shadcn/ui나 디자인 시스템 스킬에 따른 커스텀 컴포넌트. 모바일에서는 플랫폼 네이티브 패턴. 엄격한 경계: 상태 관리, 데이터 페칭, 라우팅 없음.

**web-vitals-auditor** — 자동 성능 감사. 앱을 빌드하고 서빙한 다음, 데스크탑과 모바일 모두에서 Lighthouse를 실행한다. 타겟: LCP < 2.5s, INP < 200ms, CLS < 0.1, TTFB < 800ms, FCP < 1.8s. 점수, 번들 분석, 실행 가능한 권장 사항이 포함된 리포트를 출력한다.

### 기획 에이전트

**ux-designer** — 퍼스트 프린시플에서 시작하는 설계. 5단계 프로세스: 문제 정의 → 사용자 여정 매핑 → 인터랙션 설계 → 마찰 제거 → 접근성 검증. 사용자 플로우, 주요 액션과 정보 계층이 포함된 화면 스펙을 산출한다.

**copywriter** — 프로덕트 카피와 UX 마이크로카피. 6가지 설득 원칙: 메시지는 하나만, 확실성이 최대 보상을 이긴다, 참신함만으로 충분하다, 구체적 행동을 명시하라, 집합의 힘, 한 메시지로 써라. 글자 수와 A/B 테스트 제안이 포함된 2–3개 변형을 제공한다.

UX 디자이너와 카피라이터는 파이프라인으로 동작한다: 디자이너가 플로우를 만들고, 설득력 있는 텍스트, CTA, 온보딩 카피, 에러 메시지는 카피라이터에게 넘긴다.

## 워크플로우 파이프라인

진짜 힘은 개별 도구가 아니라 반복 가능한 워크플로우로 조합되는 방식에 있다:

**기본 개발:**
```
구현 (스킬 사용) → [security-reviewer + tester] (병렬) → 수정 → 완료
```

**데이터 모델링:**
```
data-modeling 스킬 → database-reviewer 에이전트 → api-design 스킬 → 구현
```

**프론트엔드:**
```
nextjs 스킬 → 구현 → vercel-react-best-practices (리뷰)
```

**UX 설계:**
```
ux-designer 에이전트 → copywriter 에이전트 (설득 텍스트만)
```

모든 프로젝트가 CLAUDE.md를 통해 동일한 개발 워크플로우를 강제한다. 데이터베이스 변경이 있으면 스키마 리뷰 파이프라인이 자동으로 실행된다. 보안-테스트 병렬 패스는 모든 변경에서 발생한다. 예외 없음.

## MCP 서버: 외부 연동

Claude Code는 MCP(Model Context Protocol) 서버를 통해 외부 서비스에 연결된다. 내 셋업:

- **Context7** — 라이브러리 문서 실시간 조회
- **Playwright** — 테스트와 스크린샷을 위한 브라우저 자동화
- **Sentry** — 프로덕션 이슈 디버깅을 위한 에러 트래킹 연동
- **Neon** — 데이터베이스 직접 조작 및 스키마 관리
- **Notion** — 프로젝트 관리를 위한 워크스페이스 연동
- **GitHub** — 전체 GitHub 워크플로우 (PR, 이슈, 코드 검색)
- **D2** — 아키텍처 다이어그램 생성 (테마별 SVG로 컴파일)
- **Cloudflare** — Workers, KV, R2, D1 관리

단순한 편의 기능이 아니다. Neon MCP 덕분에 Claude Code가 컨텍스트 스위칭 없이 마이그레이션을 실행하고, 스키마를 검사하고, 쿼리를 튜닝할 수 있다. Sentry MCP 덕분에 프로덕션 에러가 디버깅 세션으로 직접 흘러들어온다. D2 MCP는 프로젝트 문서의 일부로 배포되는 아키텍처 다이어그램을 생성한다.

## 실제로 어떻게 보이나

일반적인 세션: 자연어로 기능을 설명한다. Claude Code가 CLAUDE.md를 읽고, 필요한 스킬을 로드하고, 구현을 시작한다. 완료되면 두 에이전트가 병렬로 돌아간다 — 보안 리뷰어가 취약점을 스캔하고, 테스터가 100% 커버리지로 테스트를 작성한다. 둘 중 하나라도 이슈를 찾으면 수정한다. 그런 다음 리뷰하고 배포한다.

수동으로 린터를 돌리지 않는다. 보일러플레이트 테스트를 작성하지 않는다. 기억에 의존해서 보안 체크리스트를 하지 않는다. 시스템이 처리한다.

투자는 21개 스킬을 만들고, 7개 에이전트를 구성하고, 각 프로젝트에 상세한 CLAUDE.md 파일을 작성하는 것이었다. 시간이 걸렸다. 하지만 이제 모든 프로젝트의 모든 새로운 기능에 그 축적된 지식의 혜택이 자동으로 적용된다.

## 복리 효과

각 스킬, 에이전트, CLAUDE.md 파일은 개별적으로 단순하다. 보안 체크리스트. React 규칙 세트. DBA 리뷰 프로세스. 하지만 조합되면 팀이 있는 것 같은 무언가가 된다: 내 패턴을 아는 아키텍트, 절대 잠들지 않는 보안 엔지니어, 100% 커버리지를 고집하는 QA 리드, "이게 현실에서 살아남겠나?"라고 묻는 DBA.

여러 프로덕트를 배포하는 솔로 개발자에게, 이건 번아웃과 스케일 업의 차이다.

바이브가 좋다. 에이전트가 뒤를 봐준다.
