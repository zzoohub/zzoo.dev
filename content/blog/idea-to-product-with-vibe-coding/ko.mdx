---
title: "아이디어에서 프로덕트까지, Claude Code 하나로"
description: "바이브 코딩은 코드 생성이 아니다. 기획, 설계, 구현, 품질, 운영 — 프로덕트의 전 과정을 AI와 함께 만드는 것이다. 솔로 개발자가 Claude Code만으로 아이디어를 프로덕트로 만드는 전 과정을 스텝별로 공개한다."
date: "2026-02-20"
tags:
  - vibe-coding
  - claude-code
  - ai
  - solo-developer
  - product
draft: false
---

바이브 코딩이라고 하면 대부분 AI에게 "로그인 페이지 만들어줘"라고 말하는 장면을 떠올린다. 틀렸다. 적어도 내가 하는 바이브 코딩은 그게 아니다.

내 바이브 코딩은 아이디어 하나에서 시작해서, 프로덕트 브리프를 쓰고, PRD를 만들고, 아키텍처를 설계하고, DB 스키마를 잡고, UX를 설계하고, 구현하고, 테스트하고, 보안 감사를 돌리고, 배포하는 **전 과정**이다. 코드를 짜는 건 그 중 한 단계일 뿐이다.

이전 글에서 "빌더로 살아라"고 했고, Claude Code 세팅을 공개했다. 이번 글에서는 그 도구들이 실제로 어떻게 조합되어 아이디어를 프로덕트로 바꾸는지, 전 과정을 스텝별로 풀어본다.

## 전체 파이프라인

```
아이디어
  ↓
Step 1. Product Brief — 문제 정의, 가설, 성공 기준
  ↓
Step 2. PRD — 상세 요구사항, P0/P1/P2 우선순위
  ↓
Step 3. Software Architecture — 시스템 설계, ADR, 트레이드오프
  ↓
Step 4. Database Design — 스키마, 인덱스, 마이그레이션
  ↓
Step 5. UX Design — 사용자 플로우, 화면 스펙, 인지 원칙
  ↓
Step 6. UI Prototyping — 와이어프레임, 시각적 스캐폴드
  ↓
Step 7. 구현 — 스킬 기반 개발
  ↓
Step 8. 품질 게이트 — [보안 감사 + 테스트] 병렬
  ↓
Step 9. 배포 & 운영
```

코드를 한 줄도 안 쓰는 단계가 절반 이상이다. 이게 바이브 코딩의 진짜 레버리지다. 하나씩 풀어본다.

## Step 1. Product Brief — "왜 만드는가"

아이디어가 있으면 가장 먼저 하는 건 코드 에디터를 여는 게 아니다. `/product-brief`를 실행한다.

이 스킬은 Marty Cagan(SVPG)의 **Four Risks Framework**를 기반으로 동작한다. 내가 "식단 기록 앱을 만들고 싶다"고 말하면, 스킬이 먼저 네 가지 리스크를 물어온다:

| 리스크 | 질문 | 검증 방법 |
|--------|------|-----------|
| **Value** | 사용자가 이걸 쓸 것인가? | 사용자 인터뷰, 경쟁사 분석 |
| **Usability** | 사용자가 쓸 수 있는가? | 프로토타입 테스트 |
| **Feasibility** | 우리가 만들 수 있는가? | 기술 스파이크 |
| **Viability** | 비즈니스로 성립하는가? | 수익 모델, 법적 검토 |

핵심 원칙은 **해결책이 아니라 문제부터 시작하는 것**이다. "식단 기록 앱을 만들자"가 아니라 "사람들이 식사를 기록하지 않는 이유는 입력이 너무 귀찮기 때문이다"에서 출발한다. 스킬이 이 방향을 강제한다.

산출물은 1-2 페이지의 문서다:

- **Problem** — 누가, 어떤 고통을 겪고 있고, 증거는 무엇인가
- **Hypotheses & Risks** — 가정을 명시적으로 나열하고 검증 계획을 붙인다
- **Proposed Direction** — 해결 방향 (기능 목록이 아니라 경험)
- **Non-Goals** — 이것은 하지 않는다 (스코프 크리프 방지)
- **Success Criteria** — 측정 가능한 성공 지표 2-4개
- **Open Questions** — 아직 모르는 것들의 목록

마지막 섹션이 특히 중요하다. 모르는 것을 모른다고 적는 것. 대부분의 프로젝트가 실패하는 이유는 잘못된 답이 아니라 질문하지 않은 질문 때문이다. Product Brief의 가장 큰 가치는 초기에 불확실성을 표면화하는 것이다.

이 단계에서 코드는 한 줄도 없다. 하지만 무엇을, 왜, 누구를 위해, 어디까지 만들지가 명확해진다. 이게 없이 코드부터 짜면 바이브 코딩이 아니라 AI 자동완성이다.

## Step 2. PRD — "구체적으로 무엇을 만드는가"

Product Brief가 방향을 잡으면, `/prd-craft` 스킬이 상세 요구사항 문서를 만든다. Brief가 "왜"라면, PRD는 "무엇"이다.

스킬이 먼저 **Discovery Interview**를 진행한다. 이건 건너뛸 수 없다. Brief에서 나온 정보를 기반으로 빈 곳을 물어온다:

- 타겟 사용자의 구체적인 페르소나와 사용 맥락은?
- 사용자가 현재 이 문제를 어떻게 해결하고 있는가? 뭐가 아픈가?
- 성공을 어떻게 측정할 것인가? 구체적인 숫자는?
- 명시적으로 스코프 밖인 것은?

그리고 PRD를 쓴다. 구조:

**Problem / Opportunity** — PRD에서 가장 중요한 섹션이다. "우리가 알림 시스템이 필요하다"는 문제가 아니다. "사용자의 23%가 시간 민감한 업데이트를 놓치고 있다. 앱을 하루에 한 번만 확인하기 때문이다"가 문제다. 스킬이 이 구분을 강제한다 — "해결책을 문제로 쓰지 마라"는 체크리스트가 있다.

**Functional Requirements** — P0/P1/P2로 분류된 기능 요구사항이다. P0은 "없으면 출시 불가", P1은 "있으면 좋음", P2는 "나중에". 각 요구사항은 기술 컴포넌트가 아니라 **사용자 여정**에 매핑된다. "사용자는 이메일로 비밀번호를 재설정할 수 있다"처럼 기능적으로 쓴다. "PostgreSQL에 B-tree 인덱스를 만든다"같은 구현 디테일은 여기 들어가지 않는다.

**Success Metrics** — 각 목표에 정확히 하나의 주요 지표가 있고, 구체적인 숫자와 기간이 있다. "개선한다"는 없다. "온보딩 완료율을 60%에서 80%로, 출시 후 3개월 내에" 같은 형식이다.

**Critical User Journeys** — 6가지 여정을 체계적으로 검토한다: 첫 경험(온보딩), 핵심 사용 루프, 재방문 경험, 관리/유지보수, 엣지 케이스와 에러 상태, 오프보딩/데이터 내보내기. 마지막 두 개가 자주 빠지는데, 스킬이 빠뜨리지 않도록 강제한다.

이 시점에서 기획 문서가 두 개 생겼다. Product Brief(전략적 방향)와 PRD(상세 요구사항). 두 문서 합쳐서 10-15 페이지. 코드는 여전히 한 줄도 없다.

## Step 3. Software Architecture — "어떤 구조로 만드는가"

PRD가 나오면 `/software-architect` 스킬에 넘긴다. 이 스킬이 PRD를 읽고, **Software Architecture Design Document (SADD)**를 만든다.

먼저 PRD에서 답을 못 찾는 질문들을 물어온다:

- 예상 사용자 수, 요청/초, 데이터 볼륨은?
- 어떤 경로가 레이턴시 크리티컬인가?
- 강한 일관성이 필요한 곳은? 최종적 일관성으로 충분한 곳은?
- 실시간 기능이 필요한가? (WebSocket, SSE, 폴링)
- 비용 민감도는? (솔로 개발자 vs 기업)

그리고 설계 문서를 작성한다. 핵심은 아키텍처 결정을 **두 개의 독립적인 축**으로 나눈다는 점이다:

**축 1: 시스템 아키텍처** — 서비스 간 통신 방식. 요청-응답, 이벤트 드리븐, CQRS, 이벤트 소싱, 모듈러 모놀리스 중 하나를 선택한다.

**축 2: 코드 구조** — 각 서비스 내부 구조. 헥사고날(포트 & 어댑터), 클린, 레이어드 중 하나를 선택한다.

이 두 축은 자유롭게 조합된다. 내 대부분의 솔로 프로젝트는 "모듈러 모놀리스 + 헥사고날"이다. 마이크로서비스의 운영 복잡도를 감당할 인력이 나 혼자뿐이고, 헥사고날은 테스트와 어댑터 교체에 유리하니까.

중요한 건 기술 선택 하나하나에 **ADR(Architecture Decision Record)**이 붙는다는 점이다. 단순히 "Axum을 쓴다"가 아니라:

> **ADR-1: Backend Language & Framework**
> - Context: 1인 개발, B2C 서비스, 비용 민감
> - Decision: Rust + Axum
> - Alternatives: Python/FastAPI (rejected — 런타임 오버헤드, 높은 메모리 사용), Go/Gin (rejected — 타입 시스템이 약함)
> - Consequences: (+) Sub-ms 응답, 10-30MB 메모리, 컴파일 타임 검증 / (-) 컴파일 시간, 생태계 규모

스킬에는 인프라 선호도 reference가 내장되어 있다. 솔로 개발자 맥락에서의 기본 선택지:
- DB는 Neon(서버리스, 스케일 투 제로, 브랜칭)
- 백엔드 컴퓨트는 GCP Cloud Run(컨테이너 기반, 오토스케일링, 넉넉한 무료 티어)
- 프론트엔드는 Cloudflare Workers + Next.js(엣지 SSR, 예측 가능한 비용)
- 모바일은 Expo(React Native)
- 오브젝트 스토리지는 Cloudflare R2(이그레스 무료)
- IaC는 Pulumi(TypeScript 네이티브)
- 에러 트래킹은 Sentry, 분석은 PostHog

이 기본값들이 있으니 매번 처음부터 고민할 필요가 없다. 프로젝트 요구사항이 기본값과 다르면 그때만 편차와 이유를 ADR로 기록한다.

실제 Mealio 프로젝트의 경우: Expo(모바일) + Axum(API) + Neon(DB) + GCP Cloud Run(컴퓨트) + Cloudflare R2(사진 저장) + Pulumi(인프라). 이 조합이 SADD에서 결정되었고, 각 선택에 대한 근거가 문서화되어 있다.

## Step 4. Database Design — "데이터를 어떻게 저장하는가"

아키텍처가 잡히면 `database-design` 스킬이 스키마를 설계한다. 이 스킬에는 reference 파일이 7개 달려 있다:

| Reference | 역할 |
|-----------|------|
| `acid-transactions.md` | 트랜잭션 격리 수준, 락 전략, 데드락 방지 |
| `data-types-guide.md` | PostgreSQL 타입 선택 가이드 |
| `design-patterns.md` | 테이블 상속, 소프트 삭제, 감사 추적, 시간적 데이터 |
| `indexing-strategy.md` | 인덱스 종류, 선택도 계산, 부분 인덱스 |
| `migration-patterns.md` | 무중단 마이그레이션, 롤백 스크립트 |
| `normalization-guide.md` | 정규화/비정규화 판단 기준 |
| `performance-patterns.md` | 쿼리 패턴 최적화, 칼럼 정렬, 파티셔닝 |

스킬의 워크플로우는 체계적이다:

**Step 1 — 요구사항 수집.** SADD가 있으면 거기서 도메인 엔티티, 데이터 플로우, 스토리지 전략, 일관성 모델을 추출한다. SADD에서 이미 결정된 시스템 수준 결정(DB 플랫폼, 아키텍처 패턴)은 따르고, DB 도메인 결정(정규화 수준, 파티셔닝 전략, 인덱스 설계, 트랜잭션 격리 수준)은 독립적으로 평가한다.

**Step 2 — 스키마 설계.** 핵심 엔티티를 식별하고, 최소 3NF까지 정규화하고, 비정규화 필요성을 평가하고, 적절한 데이터 타입을 선택하고, 제약조건(PK, FK, UNIQUE, CHECK, NOT NULL)을 정의한다. 칼럼은 가장 큰 데이터 타입부터 정렬해서 alignment padding 낭비를 줄인다.

**Step 3 — 트랜잭션 & 동시성 설계.** 명시적인 트랜잭션 설계가 필요한 작업을 식별한다: 결제, 재고 관리, 멀티 스텝 워크플로우, 고경합 리소스. 각각에 대해 격리 수준, 락 전략, 재시도 로직을 결정한다.

**Step 4 — DDL 작성.** PostgreSQL 문법으로 CREATE TABLE, INDEX, COMMENT를 작성한다.

**Step 5 — 인덱스 전략.** PostgreSQL은 FK에 자동 인덱스를 만들지 않는다는 건 자주 빠지는 실수다. 스킬이 이걸 자동으로 체크한다. WHERE, JOIN, ORDER BY에 자주 쓰이는 칼럼을 식별하고, 선택도를 계산하고, Partial Index, Expression Index, Covering Index 등 적절한 인덱스 종류를 선택한다.

**Step 6 — 성능 리뷰.** EXPLAIN ANALYZE로 실행 계획을 검증하고, 커넥션 풀링, 파티셔닝 필요성을 평가한다.

**Step 7 — 마이그레이션 계획.** 버전 관리되는 마이그레이션 스크립트와 필수 롤백 스크립트. 무중단 마이그레이션 전략.

여기서 Neon MCP가 빛을 발한다. 스키마를 설계하고, 같은 세션에서 마이그레이션을 실행하고, 결과를 검증할 수 있다. 터미널을 열어 psql에 접속할 필요가 없다. 컨텍스트 스위칭 제로.

핵심 규칙들이 하드코딩되어 있다: 금전 값에 FLOAT 쓰지 마라(NUMERIC 써라), 항상 TIMESTAMPTZ 써라, 모든 테이블에 created_at/updated_at 넣어라, FK 칼럼에 인덱스 만들어라. 이런 걸 매번 기억할 필요 없이 스킬이 강제한다.

## Step 5. UX Design — "사용자가 어떻게 쓰는가"

`ux-designer` 에이전트가 사용자 경험을 설계한다. 이 에이전트는 다른 에이전트들과 달리 **planning** 카테고리에 있고, Opus 모델을 사용한다. 설계는 추론이 깊어야 하니까.

에이전트가 가장 먼저 하는 건 3개의 reference 파일을 로드하는 것이다:

**`cognitive-principles.md`** — Hick's Law(선택지가 많을수록 결정이 느리다), Fitts's Law(타겟이 작고 멀수록 조작이 어렵다), 인지 부하 이론, Goal Gradient(완료에 가까울수록 동기가 증가한다), Peak-End Rule(경험의 기억은 절정과 끝에 지배된다). 모든 설계 결정에 이 원칙들이 태그된다.

**`design-process.md`** — 5단계 프로세스: 문제 정의 → 사용자 여정 매핑 → 인터랙션 설계 → 마찰 제거 → 접근성 검증. 순서를 건너뛰거나 바꿀 수 없다.

**`ergonomics.md`** — 터치 타겟 44px 이상, 컬러 대비 4.5:1(텍스트), 3:1(UI), 포커스 아웃라인 2px 이상, 모바일 thumb zone 배치. 구체적인 수치 기준.

모든 작업의 시작은 **First Principles Checklist**다:

1. 사용자의 **하나의 목표**는 무엇인가? (기능이 아니라, 비즈니스 메트릭이 아니라, 실제 의도)
2. 그 목표를 달성하는 데 **최소한으로 필요한 것**은? (정보, 액션, 화면)
3. **제거할 수 있는 것**은? (제거해도 목표 달성에 지장 없으면 제거한다)

세 번째가 핵심이다. 기능을 추가하는 건 쉽다. 빼는 게 어렵다. 이 에이전트는 모든 요소에 "이게 사용자의 목표에 도움이 되는가?" 테스트를 적용하고, 통과 못 하면 제거한다.

산출물:

- **User Flow** — 진입점에서 목표 완료까지의 경로, 결정 포인트별 기본값 추천, 에러와 엣지 케이스 처리
- **Screen Specifications** — 화면별로 하나의 주요 액션(시각적으로 지배적), 현재 결정에 필요한 정보만 표시, 부차적 액션(시각적으로 억제), 피드백 메커니즘
- **Accessibility Notes** — 대비, 포커스 상태, 키보드 네비게이션, 스크린 리더
- **Design Rationale** — 각 결정에 어떤 인지 원칙이 근거인지 명시

안티패턴 리스트도 있다: 마케팅 카피, 모호한 가치 제안의 히어로 섹션, 장식적인 섹션, 불필요한 온보딩, 비파괴적 작업에 대한 확인 다이얼로그, "다른 앱에 있으니까" 넣는 요소. 전부 금지.

## Step 6. UI Prototyping — "어떻게 보이는가"

UX 스펙이 나오면 `ui-engineer` 에이전트가 시각적 스캐폴드를 만든다. 이 에이전트의 핵심 규칙: **비즈니스 로직 제로**.

웹이면 shadcn/ui를 기본으로 쓰고, 커버하지 못하는 컴포넌트는 `design-system` 스킬에 따라 커스텀으로 만든다. 모바일이면 플랫폼 네이티브 패턴.

산출물은 순수 UI 컴포넌트다:
- `useState`, `useEffect` 없음
- 데이터 페칭 없음
- 이벤트 핸들러에 비즈니스 로직 없음
- Props는 시각적 제어용으로만 사용

```tsx
// ui-engineer가 만드는 것: 순수 UI 스캐폴드
export function LoginPage() {
  return (
    <Card>
      <Card.Header>
        <Card.Title>Login</Card.Title>
      </Card.Header>
      <Card.Content className="flex flex-col gap-4">
        <FormField label="Email">
          <Input type="email" placeholder="email@example.com" />
        </FormField>
        <FormField label="Password">
          <Input type="password" />
        </FormField>
      </Card.Content>
      <Card.Footer>
        <Button variant="primary" fullWidth>Sign In</Button>
      </Card.Footer>
    </Card>
  );
}

// 나중에 내가(또는 다른 에이전트가) 추가하는 것:
// - const [email, setEmail] = useState('')
// - const { mutate: login } = useLogin()
// - onSubmit handler
// - error states
// - redirect after success
```

왜 이렇게 분리하는가? UI와 로직의 경계가 명확하면 디자인이 바뀌어도 로직은 안 건드리고, 로직이 바뀌어도 UI는 안 건드린다. 실제로 이 분리가 유지보수에서 큰 차이를 만든다.

이 에이전트는 작업 완료 후 `frontend-design` 스킬을 로드해서 자체 리뷰를 수행한다. 하드코딩 값이 없는지, 모든 시각적 상태가 정의되었는지, 접근성이 충족되는지 체크리스트를 돌린다.

## Step 7. 구현 — "스킬이 컨벤션을 강제한다"

드디어 코드를 쓴다. 하지만 그냥 쓰는 게 아니다.

**CLAUDE.md가 프로젝트에 맞는 스킬을 강제한다.** 모든 프로젝트 루트에 CLAUDE.md 파일이 있고, 거기에 "모든 구현은 반드시 지정된 스킬을 사용한다"가 하드 룰로 적혀 있다.

- Next.js 프로젝트 → `nextjs` 스킬 + `vercel-react-best-practices` + `vercel-composition-patterns`
- Rust API → `axum` 스킬 + `postgresql` 스킬
- React Native 앱 → `react-native` 스킬 + `vercel-react-native-skills`
- 헥사고날 아키텍처 → `axum-hexagonal` 또는 `fastapi-hexagonal` 스킬

각 스킬이 무엇을 하는지 구체적으로:

**`axum` 스킬** — Axum 0.8+에 맞는 프로덕션 패턴을 로드한다. 라우터 구성, 핸들러 시그니처, 에러 핸들링, 미들웨어 스택, SQLx 사용법. reference 파일에 14,000자 분량의 코드 예제가 들어 있다.

**`axum-hexagonal` 스킬** — 헥사고날 아키텍처의 도메인, 포트, 어댑터 경계를 구체적인 Rust 코드로 가이드한다. reference 파일이 3개: 도메인 예제, 어댑터 예제, 부트스트랩 예제. 합치면 18,000자 이상. Step 3에서 결정한 아키텍처가 코드 수준에서 자동으로 관철된다.

**`postgresql` 스킬** — 쿼리 작성, 최적화, 프로덕션 운영 패턴. EXPLAIN ANALYZE 가이드, 인덱싱 함정, 쿼리 패턴, 프로덕션 운영 reference가 따로 있다. 진단 SQL 스크립트까지 내장.

**`vercel-react-best-practices`** — Vercel이 공식 제공하는 스킬이다. 8개 카테고리에 걸친 45개 규칙. 워터폴 방지, 번들 최적화, 서버사이드 패턴, 리렌더 방지가 전부 CRITICAL 우선순위. 프레임워크를 만든 사람들이 "이렇게 써라"를 인코딩한 것이다.

**MCP 서버들이 구현을 가속한다:**
- **Context7** — 라이브러리 최신 문서를 실시간으로 가져온다. 오래된 API 사용하는 실수를 방지
- **Neon MCP** — 마이그레이션 실행, 스키마 검사, 쿼리 튜닝을 같은 세션에서
- **D2 MCP** — 아키텍처 다이어그램을 D2 언어로 작성하고 라이트/다크 테마 SVG로 컴파일
- **Playwright MCP** — 브라우저 자동화로 실제 렌더링 확인, 스크린샷
- **Sentry MCP** — 프로덕션 에러가 디버깅 세션으로 직접 흘러들어옴
- **PostHog MCP** — 분석 데이터를 코드 맥락에서 직접 조회

**LSP 플러그인들** — TypeScript LSP, Pyright LSP, Rust Analyzer LSP. Claude Code가 코드를 작성하면서 실시간으로 타입 체크와 자동완성을 받는다. 특히 Rust Analyzer는 컴파일 에러를 에디터 수준에서 미리 잡아준다.

컨텍스트 스위칭이 없다. 하나의 Claude Code 세션에서 코드를 쓰고, DB 마이그레이션을 돌리고, 문서를 찾고, 다이어그램을 만든다.

## Step 8. 품질 게이트 — "타협 없음"

구현이 끝나면 **두 에이전트가 병렬로 돌아간다.** 이건 CLAUDE.md에 하드코딩된 규칙이다. 모든 구현, 모든 변경에서 예외 없이 실행된다.

### Tester 에이전트

**목표: 100% 커버리지.** 라인, 브랜치, 함수, 구문 — 전부.

프로세스:
1. **분석** — 변경된 코드의 모든 파일, 함수, 브랜치를 매핑
2. **기존 테스트 실행** — 커버리지로 갭 확인
3. **계획** — 커버리지 안 된 모든 라인, 브랜치, 함수 목록
4. **작성** — 갭을 채우는 테스트 작성 (우선순위: 크리티컬 패스 → 비즈니스 로직 → 통합 포인트 → CRUD → UI → 유틸 → 에러 패스)
5. **실행** — 커버리지 리포트와 함께
6. **반복** — 100%가 될 때까지. 99%는 100%가 아니다

브랜치 커버리지 체크리스트: if/else 양쪽, switch/match 모든 케이스 + default, try/catch 성공과 실패, 삼항 연산자 양쪽, 논리 단축평가 양쪽, null/optional 값 있음과 없음, early return 트리거됨과 안 됨, 루프 0회/1회/다회.

**핵심 규칙: 이 에이전트는 절대 애플리케이션 코드를 수정하지 않는다.** 테스트 파일만 작성한다. 코드에 문제가 있으면 나에게 리포트한다.

### Security Reviewer 에이전트

**Assume breach mentality** — 모든 입력은 악의적이고, 모든 의존성은 침해되었다고 가정한다.

프로세스:
1. **Quick Scan** — 하드코딩된 시크릿, .env 노출, 디버그 모드, 위험한 패턴
2. **Domain Analysis** — `security-checklists` 스킬의 4개 체크리스트 기반: Auth, API, 비즈니스 로직, 서플라이 체인
3. **Severity Classification** — 심각도별 분류

| Auto-Fail 패턴 | 리스크 |
|----------------|--------|
| 코드/로그에 시크릿 | 인증정보 노출 |
| 사용자 입력이 쿼리 문자열 결합에 사용 | SQL 인젝션 |
| 사용자 입력이 shell/system 호출에 사용 | 커맨드 인젝션 |
| 사용자 입력이 eval/exec에 사용 | 원격 코드 실행 |
| 사용자 콘텐츠가 HTML에 직접 출력 | XSS |
| 전체 요청 바디가 모델 업데이트에 전달 | 매스 어사인먼트 |

**에스컬레이션 규칙** — 결제/금융 로직, 인증 시스템 변경, 암호화 구현, 민감 데이터를 다루는 서드파티 연동, 컴플라이언스(GDPR, PCI-DSS) 관련 코드는 무조건 나에게 올린다. AI가 단독으로 판단하면 안 되는 영역이다.

두 에이전트가 병렬로 돌아가는 이유는 간단하다. 서로 독립적인 작업이고, 직렬로 돌리면 시간만 낭비된다. 하나가 테스트를 쓰는 동안 다른 하나가 취약점을 찾는다. 둘 다 이슈를 찾으면 수정하고, 다시 돌린다. 통과할 때까지.

## Step 9. 배포 & 운영 — "만든 걸 세상에 내보낸다"

코드가 품질 게이트를 통과하면 배포한다. 인프라도 Step 3에서 이미 결정되어 있다.

**Pulumi**로 인프라를 코드로 관리한다. TypeScript로 GCP Cloud Run, Secret Manager, Artifact Registry, Cloudflare R2, Neon을 정의한다. HCL을 따로 배울 필요가 없다. `pulumi-authoring` 플러그인이 ComponentResource 작성, Output 핸들링, 시크릿 관리 패턴을 가이드한다.

배포 후:
- **Sentry MCP** — 프로덕션 에러가 발생하면 Claude Code 세션에서 바로 확인하고 디버깅한다
- **PostHog MCP** — 사용자 행동 데이터를 코드 맥락에서 조회한다. 퍼널 분석, 이벤트 추적, A/B 테스트
- **Cloudflare MCP** — Workers, KV, R2, D1을 관리한다

운영 중 발견되는 이슈는 다시 파이프라인을 탄다. 버그 수정도 스킬을 로드하고, 구현 후 tester + security-reviewer가 병렬로 돌아간다. 예외 없음.

## 문서는 살아 있다

내 워크플로우에서 문서 관리는 부가 작업이 아니라 **개발의 일부**다. 두 가지 규칙:

**1. 요구사항이 바뀌면 모든 관련 문서를 업데이트한다.** PRD에서 기능이 빠지면 SADD도, DB 설계도, UX 스펙도 업데이트한다. 문서와 현실이 어긋나는 순간 AI는 잘못된 문서를 신뢰하고 잘못된 코드를 만든다.

**2. 개발 단위가 큰 작업 이후에는 CLAUDE.md를 업데이트한다.** 새 모듈이 생기면 폴더 구조, 컨벤션, 의존성 관계가 CLAUDE.md에 반영된다. 다음 세션에서 Claude Code가 이 파일을 읽고, 프로젝트의 현재 상태를 완전히 이해한 채로 시작한다.

Mealio의 CLAUDE.md를 보면 이게 실감된다. 모바일의 Feature-Sliced Design 구조, 듀얼 모드 아키텍처(인증/게스트), 업로드 큐의 동작 방식, AI 분석의 Trigger-and-Poll 패턴, TanStack Query 키 관리 방식, Jest 테스트의 gotchas — 전부 적혀 있다. 이건 189줄짜리 살아있는 문서다.

`claude-md-management` 플러그인이 이걸 도와준다. `/revise-claude-md`로 현재 세션에서 배운 것을 CLAUDE.md에 반영할 수 있다.

## 한 사람, 여러 역할

이 파이프라인을 쓰면 한 사람이 여러 역할을 오간다:

| Step | 역할 | 스킬/에이전트 |
|------|------|---------------|
| 1. Product Brief | PM | `product-brief` 스킬 |
| 2. PRD | 프로덕트 매니저 | `prd-craft` 스킬 |
| 3. Architecture | 소프트웨어 아키텍트 | `software-architect` 스킬 |
| 4. Database | DBA | `database-design` + `postgresql` 스킬 |
| 5. UX Design | UX 디자이너 | `ux-designer` 에이전트 |
| 6. UI Prototype | UI 엔지니어 | `ui-engineer` 에이전트 |
| 7. Implementation | 개발자 | `axum`, `nextjs`, `react-native` 등 |
| 8. Quality Gate | QA + 보안 엔지니어 | `tester` + `security-reviewer` 에이전트 |
| 9. Deploy | DevOps | Pulumi + Cloudflare + GCP |

예전에는 이 역할들을 각각 다른 사람이 했다. 지금은 각 역할에 맞는 스킬이 로드되고, 그 역할의 프레임워크와 제약 조건이 적용된다. 내가 해당 분야의 전문가일 필요는 없다 — 전문가의 사고방식이 스킬에 인코딩되어 있으니까.

## 한계

솔직하게 말해야 한다. 이 시스템에도 한계가 있다.

**도메인 감각은 대체 안 된다.** 스킬이 "문제를 증거에 기반해서 정의하라"고 가이드하지만, 어떤 문제가 진짜 아픈지, 돈이 되는지, 사용자가 실제로 원하는지는 내가 판단해야 한다. Product Brief를 쓰는 건 AI지만, 그 Brief에 넣을 인사이트는 사용자를 관찰해야 나온다.

**UX 감각도 마찬가지다.** 인지 원칙에 기반한 설계는 나쁜 결정을 방지해주지만, 정말로 자연스럽고 기분 좋은 경험을 만드는 건 결국 직접 써보고 느끼는 것에서 온다.

**스킬의 품질이 전부다.** 스킬이 잘못 작성되면 잘못된 패턴이 모든 프로젝트에 전파된다. 정기적으로 스킬을 리뷰하고 업데이트해야 한다.

하지만 이 한계들은 시스템의 결함이 아니라 시스템의 설계다. AI는 프레임워크를 제공하고, 나는 그 프레임워크에 재료를 넣는다. 역할 분담이다.

## 복리 효과

이 시스템의 진짜 가치는 시간이 지날수록 나타난다.

첫 프로젝트에서 만든 스킬과 에이전트가 두 번째 프로젝트에서 그대로 쓰인다. 두 번째 프로젝트에서 개선한 CLAUDE.md 패턴이 세 번째 프로젝트에 적용된다. 보안 체크리스트에서 발견한 새로운 패턴이 스킬에 추가되고, 이후 모든 프로젝트에서 자동으로 검사된다.

스킬 21개, 에이전트 7개, MCP 서버 8개, 플러그인 20개를 구성하는 데 시간이 걸렸다. 각 프로젝트에 상세한 CLAUDE.md를 작성하는 데도 시간이 걸린다. 하지만 이 투자는 복리로 돌아온다. 새 프로젝트를 시작할 때마다 이전에 축적된 모든 지식이 자동으로 적용된다.

## 바이브 코딩의 진짜 의미

바이브 코딩은 AI에게 코드를 받아내는 게 아니다. **프로덕트를 만드는 전 과정에서 AI를 지휘하는 것이다.**

아이디어에서 시작해서 문제를 정의하고(Product Brief), 요구사항을 구체화하고(PRD), 구조를 설계하고(SADD), 데이터를 모델링하고(DB Design), 사용자 경험을 그리고(UX), 시각적 스캐폴드를 만들고(UI), 코드를 구현하고(Skills), 품질을 검증하는(Tester + Security) 전 과정. 각 단계에서 전문가 수준의 프레임워크가 로드되고, 나는 방향을 잡고 판단을 내린다.

타이피스트가 아니라 디렉터.

이전 글에서 "빌더로 살아라"고 했다. 이 파이프라인이 빌더를 위한 인프라다. 아이디어만 있으면 된다 — 나머지는 시스템이 스캐폴딩해준다.

바이브가 좋다. 파이프라인이 뒤를 봐준다.
